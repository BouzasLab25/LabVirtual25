mtext("Tasa Hits",2,cex=2, line=2.5, f=2)
mtext("Discriminabilidad baja",3,cex=3, line=-3, f=2, outer=TRUE)
}
# d' pequeña
rm(list=ls())
for(i in 1:1){
layout(matrix(1:2,ncol=2))
h_rate<- 0.84
fa_rate<- 0.49
k<-qnorm(1-fa_rate,0,1)   #Calculamos la localizacion del Criterio
d<-qnorm(h_rate,0,1)-qnorm(fa_rate,0,1)     #Calculamos d'
c<-k-(d/2)                                  #Calculamos el Sesgo c
beta<-dnorm(k,d,1)/dnorm(k,0,1)             #Calculamos el Sesgo Beta
plot(c(k, k), c(35,35), main="", xlab="", ylab="",type='p', font.lab=2, axes = "FALSE",
xlim= c(-3.5,4.5),  ylim= c(0,.53), pch=16, color='black', cex=2)
lines(seq(k,10,.05),dnorm(seq(k,10,.05),0,1),type='l', lwd=4, col='firebrick3') #FA
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),0,1),type='l', lwd=4, col='dodgerblue3') #Rej
lines(seq(k,10,.05),dnorm(seq(k,10,.05),d,1),type='l', lwd=4, col='forestgreen') #Hit
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),d,1),type='l', lwd=4, col='darkorchid3') #Miss
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),0,1),type='l', lwd=1, lty=3, col='white') #NOISE
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),d,1),type='l', lwd=1, lty=3, col='black') #SIGNAL
axis(1,at=c(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5), labels=c(-4:5), font=2)
lines(c(k,k),c(-0.2,0.48), lwd=2, col='red')
text(-2.3,.45,paste("Falsa Alarma"), cex=1.2, col='firebrick3', f=2)
text(-2.5,.41,paste("Rechazo C."), cex=1.2, col='dodgerblue3', f=2)
text(-3.5,.37,paste("Hit"), cex=1.2, col='forestgreen', f=2)
text(0.5,.17,paste("K"), cex=1.2, col='red', f=2)
text(-2.6,.33,paste("Omisión"), cex=1.2, col='darkorchid3', f=2)
mtext("Evidencia",1,cex=2, line=2.5, f=2)
mtext("d' = 1",3,cex=3, line=-2, f=2)
hits <- c()   #Creamos un arreglo vacío, que vamos a ir llenando con el Ciclo For, para las tasas de Hits
falarms <- c()  #Creamos un arreglo vacío para las tasas de Falsas Alarmas
bias_c <- seq(-10,10,0.1)
d_null <- 0  #Como referencia, vamos a incluir una curva ROC para una d' de 0. El sistema a evaluar será juzgado como 'más preciso' conforme su ROC se aleje de ésta función de identidad.
hits_na <- c()     #Creamos un arreglo vacío para los hits en  d' 0
falarms_na <- c()  # Creamos un arreglo vacío para las falsas alarmas en d' 0
for (i in 1:length(bias_c)){                     #Creamos un For donde, para cada posible valor del sesgo C (que relaciona directamente d' con el criterio)
hits[i] <- pnorm((-d/2)-bias_c[i])             #se compute la proporción de la distribución de señal que cae sobre el criterio
falarms[i] <- pnorm((d/2)-bias_c[i])           # y la proporción de la distribución de ruido.
hits_na[i] <- pnorm((d_null/2)-bias_c[i])      #Para referencia, realizamos el mismo cómputo para la d' de 0
falarms_na[i] <- pnorm((-d_null/2)-bias_c[i])
}
plot(fa_rate,h_rate, axes=F, ann=F,  pch=16, col='deepskyblue4', xlim=c(0,1), ylim=c(0,1.1), xlab='F.A. Rate', ylab='Hit Rate')     #Ploteamos las tasas de hits y falsas alarmas obervadas como un punto en el espacio
axis(1,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
axis(2,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
lines(hits,falarms,lwd=2,col='deepskyblue2')        #Dibujamos la curva ROC correspondiente a la d' de nuestro sistema evaluado
lines(hits_na,falarms_na,lwd=1,col='black', lty=2)  #Dibujamos la función de identidad, que corresponde a una d' de 0 (Donde las distribuciones de ruido y señal se empalman por completo)
#lines(c(0.3, 0.38),c(0.25,0.25), lwd=2, lty=1, col="deepskyblue3")
#text(0.3, 0.2, labels="Relaciones posibles entre Hits-F.A., dada la d'", offset=0, cex = 0.7, pos=4)
#text(0.3, 0.1, labels="Relación Hits-F.A. registrada", offset=0, cex = 0.7, pos=4)
#points(.25,0.1, lty=3, pch=16, col='deepskyblue4')
text(fa_rate-0.23, h_rate+0.02, paste("d' =", round(d,4)), offset=0, cex = 0.8, pos=4)
mtext("ROC",3,cex=3, line=-2, f=2)
mtext("Tasa F.A.",1,cex=2, line=2.5, f=2)
mtext("Tasa Hits",2,cex=2, line=2.5, f=2)
mtext("Discriminabilidad baja",3,cex=3, line=-3, f=2, outer=TRUE)
}
# d' pequeña
rm(list=ls())
for(i in 1:1){
layout(matrix(1:2,ncol=2))
h_rate<- 0.84
fa_rate<- 0.49
k<-qnorm(1-fa_rate,0,1)   #Calculamos la localizacion del Criterio
d<-qnorm(h_rate,0,1)-qnorm(fa_rate,0,1)     #Calculamos d'
c<-k-(d/2)                                  #Calculamos el Sesgo c
beta<-dnorm(k,d,1)/dnorm(k,0,1)             #Calculamos el Sesgo Beta
plot(c(k, k), c(35,35), main="", xlab="", ylab="",type='p', font.lab=2, axes = "FALSE",
xlim= c(-3.5,4.5),  ylim= c(0,.53), pch=16, color='black', cex=2)
lines(seq(k,10,.05),dnorm(seq(k,10,.05),0,1),type='l', lwd=4, col='firebrick3') #FA
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),0,1),type='l', lwd=4, col='dodgerblue3') #Rej
lines(seq(k,10,.05),dnorm(seq(k,10,.05),d,1),type='l', lwd=4, col='forestgreen') #Hit
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),d,1),type='l', lwd=4, col='darkorchid3') #Miss
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),0,1),type='l', lwd=1, lty=3, col='white') #NOISE
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),d,1),type='l', lwd=1, lty=3, col='black') #SIGNAL
axis(1,at=c(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5), labels=c(-4:5), font=2)
lines(c(k,k),c(-0.2,0.48), lwd=2, col='red')
text(-2.3,.45,paste("Falsa Alarma"), cex=1.2, col='firebrick3', f=2)
text(-2.5,.41,paste("Rechazo C."), cex=1.2, col='dodgerblue3', f=2)
text(-3.5,.37,paste("Hit"), cex=1.2, col='forestgreen', f=2)
text(0.5,.17,paste("K"), cex=1.2, col='red', f=2)
text(-2.5,.33,paste("Omisión"), cex=1.2, col='darkorchid3', f=2)
mtext("Evidencia",1,cex=2, line=2.5, f=2)
mtext("d' = 1",3,cex=3, line=-2, f=2)
hits <- c()   #Creamos un arreglo vacío, que vamos a ir llenando con el Ciclo For, para las tasas de Hits
falarms <- c()  #Creamos un arreglo vacío para las tasas de Falsas Alarmas
bias_c <- seq(-10,10,0.1)
d_null <- 0  #Como referencia, vamos a incluir una curva ROC para una d' de 0. El sistema a evaluar será juzgado como 'más preciso' conforme su ROC se aleje de ésta función de identidad.
hits_na <- c()     #Creamos un arreglo vacío para los hits en  d' 0
falarms_na <- c()  # Creamos un arreglo vacío para las falsas alarmas en d' 0
for (i in 1:length(bias_c)){                     #Creamos un For donde, para cada posible valor del sesgo C (que relaciona directamente d' con el criterio)
hits[i] <- pnorm((-d/2)-bias_c[i])             #se compute la proporción de la distribución de señal que cae sobre el criterio
falarms[i] <- pnorm((d/2)-bias_c[i])           # y la proporción de la distribución de ruido.
hits_na[i] <- pnorm((d_null/2)-bias_c[i])      #Para referencia, realizamos el mismo cómputo para la d' de 0
falarms_na[i] <- pnorm((-d_null/2)-bias_c[i])
}
plot(fa_rate,h_rate, axes=F, ann=F,  pch=16, col='deepskyblue4', xlim=c(0,1), ylim=c(0,1.1), xlab='F.A. Rate', ylab='Hit Rate')     #Ploteamos las tasas de hits y falsas alarmas obervadas como un punto en el espacio
axis(1,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
axis(2,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
lines(hits,falarms,lwd=2,col='deepskyblue2')        #Dibujamos la curva ROC correspondiente a la d' de nuestro sistema evaluado
lines(hits_na,falarms_na,lwd=1,col='black', lty=2)  #Dibujamos la función de identidad, que corresponde a una d' de 0 (Donde las distribuciones de ruido y señal se empalman por completo)
#lines(c(0.3, 0.38),c(0.25,0.25), lwd=2, lty=1, col="deepskyblue3")
#text(0.3, 0.2, labels="Relaciones posibles entre Hits-F.A., dada la d'", offset=0, cex = 0.7, pos=4)
#text(0.3, 0.1, labels="Relación Hits-F.A. registrada", offset=0, cex = 0.7, pos=4)
#points(.25,0.1, lty=3, pch=16, col='deepskyblue4')
text(fa_rate-0.23, h_rate+0.02, paste("d' =", round(d,4)), offset=0, cex = 0.8, pos=4)
mtext("ROC",3,cex=3, line=-2, f=2)
mtext("Tasa F.A.",1,cex=2, line=2.5, f=2)
mtext("Tasa Hits",2,cex=2, line=2.5, f=2)
mtext("Discriminabilidad baja",3,cex=3, line=-3, f=2, outer=TRUE)
}
# d' pequeña
rm(list=ls())
for(i in 1:1){
layout(matrix(1:2,ncol=2))
h_rate<- 0.84
fa_rate<- 0.49
k<-qnorm(1-fa_rate,0,1)   #Calculamos la localizacion del Criterio
d<-qnorm(h_rate,0,1)-qnorm(fa_rate,0,1)     #Calculamos d'
c<-k-(d/2)                                  #Calculamos el Sesgo c
beta<-dnorm(k,d,1)/dnorm(k,0,1)             #Calculamos el Sesgo Beta
plot(c(k, k), c(35,35), main="", xlab="", ylab="",type='p', font.lab=2, axes = "FALSE",
xlim= c(-3.5,4.5),  ylim= c(0,.53), pch=16, color='black', cex=2)
lines(seq(k,10,.05),dnorm(seq(k,10,.05),0,1),type='l', lwd=4, col='firebrick3') #FA
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),0,1),type='l', lwd=4, col='dodgerblue3') #Rej
lines(seq(k,10,.05),dnorm(seq(k,10,.05),d,1),type='l', lwd=4, col='forestgreen') #Hit
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),d,1),type='l', lwd=4, col='darkorchid3') #Miss
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),0,1),type='l', lwd=1, lty=3, col='white') #NOISE
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),d,1),type='l', lwd=1, lty=3, col='black') #SIGNAL
axis(1,at=c(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5), labels=c(-4:5), font=2)
lines(c(k,k),c(-0.2,0.48), lwd=2, col='red')
text(-2.3,.45,paste("Falsa Alarma"), cex=1.2, col='firebrick3', f=2)
text(-2.5,.41,paste("Rechazo C."), cex=1.2, col='dodgerblue3', f=2)
text(-3.5,.37,paste("Hit"), cex=1.2, col='forestgreen', f=2)
text(0.5,.17,paste("K"), cex=1.2, col='red', f=2)
text(-2.7,.33,paste("Omisión"), cex=1.2, col='darkorchid3', f=2)
mtext("Evidencia",1,cex=2, line=2.5, f=2)
mtext("d' = 1",3,cex=3, line=-2, f=2)
hits <- c()   #Creamos un arreglo vacío, que vamos a ir llenando con el Ciclo For, para las tasas de Hits
falarms <- c()  #Creamos un arreglo vacío para las tasas de Falsas Alarmas
bias_c <- seq(-10,10,0.1)
d_null <- 0  #Como referencia, vamos a incluir una curva ROC para una d' de 0. El sistema a evaluar será juzgado como 'más preciso' conforme su ROC se aleje de ésta función de identidad.
hits_na <- c()     #Creamos un arreglo vacío para los hits en  d' 0
falarms_na <- c()  # Creamos un arreglo vacío para las falsas alarmas en d' 0
for (i in 1:length(bias_c)){                     #Creamos un For donde, para cada posible valor del sesgo C (que relaciona directamente d' con el criterio)
hits[i] <- pnorm((-d/2)-bias_c[i])             #se compute la proporción de la distribución de señal que cae sobre el criterio
falarms[i] <- pnorm((d/2)-bias_c[i])           # y la proporción de la distribución de ruido.
hits_na[i] <- pnorm((d_null/2)-bias_c[i])      #Para referencia, realizamos el mismo cómputo para la d' de 0
falarms_na[i] <- pnorm((-d_null/2)-bias_c[i])
}
plot(fa_rate,h_rate, axes=F, ann=F,  pch=16, col='deepskyblue4', xlim=c(0,1), ylim=c(0,1.1), xlab='F.A. Rate', ylab='Hit Rate')     #Ploteamos las tasas de hits y falsas alarmas obervadas como un punto en el espacio
axis(1,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
axis(2,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
lines(hits,falarms,lwd=2,col='deepskyblue2')        #Dibujamos la curva ROC correspondiente a la d' de nuestro sistema evaluado
lines(hits_na,falarms_na,lwd=1,col='black', lty=2)  #Dibujamos la función de identidad, que corresponde a una d' de 0 (Donde las distribuciones de ruido y señal se empalman por completo)
#lines(c(0.3, 0.38),c(0.25,0.25), lwd=2, lty=1, col="deepskyblue3")
#text(0.3, 0.2, labels="Relaciones posibles entre Hits-F.A., dada la d'", offset=0, cex = 0.7, pos=4)
#text(0.3, 0.1, labels="Relación Hits-F.A. registrada", offset=0, cex = 0.7, pos=4)
#points(.25,0.1, lty=3, pch=16, col='deepskyblue4')
text(fa_rate-0.23, h_rate+0.02, paste("d' =", round(d,4)), offset=0, cex = 0.8, pos=4)
mtext("ROC",3,cex=3, line=-2, f=2)
mtext("Tasa F.A.",1,cex=2, line=2.5, f=2)
mtext("Tasa Hits",2,cex=2, line=2.5, f=2)
mtext("Discriminabilidad baja",3,cex=3, line=-3, f=2, outer=TRUE)
}
# d' pequeña
rm(list=ls())
for(i in 1:1){
layout(matrix(1:2,ncol=2))
h_rate<- 0.84
fa_rate<- 0.49
k<-qnorm(1-fa_rate,0,1)   #Calculamos la localizacion del Criterio
d<-qnorm(h_rate,0,1)-qnorm(fa_rate,0,1)     #Calculamos d'
c<-k-(d/2)                                  #Calculamos el Sesgo c
beta<-dnorm(k,d,1)/dnorm(k,0,1)             #Calculamos el Sesgo Beta
plot(c(k, k), c(35,35), main="", xlab="", ylab="",type='p', font.lab=2, axes = "FALSE",
xlim= c(-3.5,4.5),  ylim= c(0,.53), pch=16, color='black', cex=2)
lines(seq(k,10,.05),dnorm(seq(k,10,.05),0,1),type='l', lwd=4, col='firebrick3') #FA
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),0,1),type='l', lwd=4, col='dodgerblue3') #Rej
lines(seq(k,10,.05),dnorm(seq(k,10,.05),d,1),type='l', lwd=4, col='forestgreen') #Hit
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),d,1),type='l', lwd=4, col='darkorchid3') #Miss
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),0,1),type='l', lwd=1, lty=3, col='white') #NOISE
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),d,1),type='l', lwd=1, lty=3, col='black') #SIGNAL
axis(1,at=c(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5), labels=c(-4:5), font=2)
lines(c(k,k),c(-0.2,0.48), lwd=2, col='red')
text(-2.3,.45,paste("Falsa Alarma"), cex=1.2, col='firebrick3', f=2)
text(-2.5,.41,paste("Rechazo C."), cex=1.2, col='dodgerblue3', f=2)
text(-3.3,.37,paste("Hit"), cex=1.2, col='forestgreen', f=2)
text(0.5,.17,paste("K"), cex=1.2, col='red', f=2)
text(-2.7,.33,paste("Omisión"), cex=1.2, col='darkorchid3', f=2)
mtext("Evidencia",1,cex=2, line=2.5, f=2)
mtext("d' = 1",3,cex=3, line=-2, f=2)
hits <- c()   #Creamos un arreglo vacío, que vamos a ir llenando con el Ciclo For, para las tasas de Hits
falarms <- c()  #Creamos un arreglo vacío para las tasas de Falsas Alarmas
bias_c <- seq(-10,10,0.1)
d_null <- 0  #Como referencia, vamos a incluir una curva ROC para una d' de 0. El sistema a evaluar será juzgado como 'más preciso' conforme su ROC se aleje de ésta función de identidad.
hits_na <- c()     #Creamos un arreglo vacío para los hits en  d' 0
falarms_na <- c()  # Creamos un arreglo vacío para las falsas alarmas en d' 0
for (i in 1:length(bias_c)){                     #Creamos un For donde, para cada posible valor del sesgo C (que relaciona directamente d' con el criterio)
hits[i] <- pnorm((-d/2)-bias_c[i])             #se compute la proporción de la distribución de señal que cae sobre el criterio
falarms[i] <- pnorm((d/2)-bias_c[i])           # y la proporción de la distribución de ruido.
hits_na[i] <- pnorm((d_null/2)-bias_c[i])      #Para referencia, realizamos el mismo cómputo para la d' de 0
falarms_na[i] <- pnorm((-d_null/2)-bias_c[i])
}
plot(fa_rate,h_rate, axes=F, ann=F,  pch=16, col='deepskyblue4', xlim=c(0,1), ylim=c(0,1.1), xlab='F.A. Rate', ylab='Hit Rate')     #Ploteamos las tasas de hits y falsas alarmas obervadas como un punto en el espacio
axis(1,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
axis(2,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
lines(hits,falarms,lwd=2,col='deepskyblue2')        #Dibujamos la curva ROC correspondiente a la d' de nuestro sistema evaluado
lines(hits_na,falarms_na,lwd=1,col='black', lty=2)  #Dibujamos la función de identidad, que corresponde a una d' de 0 (Donde las distribuciones de ruido y señal se empalman por completo)
#lines(c(0.3, 0.38),c(0.25,0.25), lwd=2, lty=1, col="deepskyblue3")
#text(0.3, 0.2, labels="Relaciones posibles entre Hits-F.A., dada la d'", offset=0, cex = 0.7, pos=4)
#text(0.3, 0.1, labels="Relación Hits-F.A. registrada", offset=0, cex = 0.7, pos=4)
#points(.25,0.1, lty=3, pch=16, col='deepskyblue4')
text(fa_rate-0.23, h_rate+0.02, paste("d' =", round(d,4)), offset=0, cex = 0.8, pos=4)
mtext("ROC",3,cex=3, line=-2, f=2)
mtext("Tasa F.A.",1,cex=2, line=2.5, f=2)
mtext("Tasa Hits",2,cex=2, line=2.5, f=2)
mtext("Discriminabilidad baja",3,cex=3, line=-3, f=2, outer=TRUE)
}
# d' pequeña
rm(list=ls())
for(i in 1:1){
layout(matrix(1:2,ncol=2))
h_rate<- 0.84
fa_rate<- 0.49
k<-qnorm(1-fa_rate,0,1)   #Calculamos la localizacion del Criterio
d<-qnorm(h_rate,0,1)-qnorm(fa_rate,0,1)     #Calculamos d'
c<-k-(d/2)                                  #Calculamos el Sesgo c
beta<-dnorm(k,d,1)/dnorm(k,0,1)             #Calculamos el Sesgo Beta
plot(c(k, k), c(35,35), main="", xlab="", ylab="",type='p', font.lab=2, axes = "FALSE",
xlim= c(-3.5,4.5),  ylim= c(0,.53), pch=16, color='black', cex=2)
lines(seq(k,10,.05),dnorm(seq(k,10,.05),0,1),type='l', lwd=4, col='firebrick3') #FA
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),0,1),type='l', lwd=4, col='dodgerblue3') #Rej
lines(seq(k,10,.05),dnorm(seq(k,10,.05),d,1),type='l', lwd=4, col='forestgreen') #Hit
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),d,1),type='l', lwd=4, col='darkorchid3') #Miss
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),0,1),type='l', lwd=1, lty=3, col='white') #NOISE
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),d,1),type='l', lwd=1, lty=3, col='black') #SIGNAL
axis(1,at=c(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5), labels=c(-4:5), font=2)
lines(c(k,k),c(-0.2,0.48), lwd=2, col='red')
text(-2.3,.45,paste("Falsa Alarma"), cex=1.2, col='firebrick3', f=2)
text(-2.5,.41,paste("Rechazo C."), cex=1.2, col='dodgerblue3', f=2)
text(-3.2,.37,paste("Hit"), cex=1.2, col='forestgreen', f=2)
text(0.5,.17,paste("K"), cex=1.2, col='red', f=2)
text(-2.7,.33,paste("Omisión"), cex=1.2, col='darkorchid3', f=2)
mtext("Evidencia",1,cex=2, line=2.5, f=2)
mtext("d' = 1",3,cex=3, line=-2, f=2)
hits <- c()   #Creamos un arreglo vacío, que vamos a ir llenando con el Ciclo For, para las tasas de Hits
falarms <- c()  #Creamos un arreglo vacío para las tasas de Falsas Alarmas
bias_c <- seq(-10,10,0.1)
d_null <- 0  #Como referencia, vamos a incluir una curva ROC para una d' de 0. El sistema a evaluar será juzgado como 'más preciso' conforme su ROC se aleje de ésta función de identidad.
hits_na <- c()     #Creamos un arreglo vacío para los hits en  d' 0
falarms_na <- c()  # Creamos un arreglo vacío para las falsas alarmas en d' 0
for (i in 1:length(bias_c)){                     #Creamos un For donde, para cada posible valor del sesgo C (que relaciona directamente d' con el criterio)
hits[i] <- pnorm((-d/2)-bias_c[i])             #se compute la proporción de la distribución de señal que cae sobre el criterio
falarms[i] <- pnorm((d/2)-bias_c[i])           # y la proporción de la distribución de ruido.
hits_na[i] <- pnorm((d_null/2)-bias_c[i])      #Para referencia, realizamos el mismo cómputo para la d' de 0
falarms_na[i] <- pnorm((-d_null/2)-bias_c[i])
}
plot(fa_rate,h_rate, axes=F, ann=F,  pch=16, col='deepskyblue4', xlim=c(0,1), ylim=c(0,1.1), xlab='F.A. Rate', ylab='Hit Rate')     #Ploteamos las tasas de hits y falsas alarmas obervadas como un punto en el espacio
axis(1,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
axis(2,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
lines(hits,falarms,lwd=2,col='deepskyblue2')        #Dibujamos la curva ROC correspondiente a la d' de nuestro sistema evaluado
lines(hits_na,falarms_na,lwd=1,col='black', lty=2)  #Dibujamos la función de identidad, que corresponde a una d' de 0 (Donde las distribuciones de ruido y señal se empalman por completo)
#lines(c(0.3, 0.38),c(0.25,0.25), lwd=2, lty=1, col="deepskyblue3")
#text(0.3, 0.2, labels="Relaciones posibles entre Hits-F.A., dada la d'", offset=0, cex = 0.7, pos=4)
#text(0.3, 0.1, labels="Relación Hits-F.A. registrada", offset=0, cex = 0.7, pos=4)
#points(.25,0.1, lty=3, pch=16, col='deepskyblue4')
text(fa_rate-0.23, h_rate+0.02, paste("d' =", round(d,4)), offset=0, cex = 0.8, pos=4)
mtext("ROC",3,cex=3, line=-2, f=2)
mtext("Tasa F.A.",1,cex=2, line=2.5, f=2)
mtext("Tasa Hits",2,cex=2, line=2.5, f=2)
mtext("Discriminabilidad baja",3,cex=3, line=-3, f=2, outer=TRUE)
}
# d' grande
rm(list=ls())
for(i in 1:1){
layout(matrix(1:2,ncol=2))
h_rate<- 0.97
fa_rate<- 0.1
k<-qnorm(1-fa_rate,0,1)   #Calculamos la localizacion del Criterio
d<-qnorm(h_rate,0,1)-qnorm(fa_rate,0,1)     #Calculamos d'
c<-k-(d/2)                                  #Calculamos el Sesgo c
beta<-dnorm(k,d,1)/dnorm(k,0,1)             #Calculamos el Sesgo Beta
plot(c(k, k), c(35,35), main="", xlab="", ylab="",type='p', font.lab=2, axes = "FALSE",
xlim= c(-3.5,6.5),  ylim= c(0,.53), pch=16, color='black', cex=2)
lines(seq(k,10,.05),dnorm(seq(k,10,.05),0,1),type='l', lwd=4, col='firebrick3') #FA
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),0,1),type='l', lwd=4, col='dodgerblue3') #Rej
lines(seq(k,10,.05),dnorm(seq(k,10,.05),d,1),type='l', lwd=4, col='forestgreen') #Hit
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),d,1),type='l', lwd=4, col='darkorchid3') #Miss
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),0,1),type='l', lwd=1, lty=3, col='white') #NOISE
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),d,1),type='l', lwd=1, lty=3, col='black') #SIGNAL
axis(1,at=c(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5), labels=c(-4:5), font=2)
lines(c(k,k),c(-0.2,0.48), lwd=2, col='red')
text(-3.2,.33,paste("F.A."), cex=1.2, col='firebrick3', f=2)
text(-3.15,.41,paste("R. C."), cex=1.2, col='dodgerblue3', f=2)
text(-3.45,.37,paste("Hit"), cex=1.2, col='forestgreen', f=2)
text(0.5,.15,paste("K"), cex=1.2, col='red', f=2)
text(-2.6,.45,paste("Omisión"), cex=1.2, col='darkorchid3', f=2)
mtext("Evidencia",1,cex=2, line=2.5, f=2)
mtext("d' = 3",3,cex=3, line=-2, f=2)
hits <- c()   #Creamos un arreglo vacío, que vamos a ir llenando con el Ciclo For, para las tasas de Hits
falarms <- c()  #Creamos un arreglo vacío para las tasas de Falsas Alarmas
bias_c <- seq(-10,10,0.1)
d_null <- 0  #Como referencia, vamos a incluir una curva ROC para una d' de 0. El sistema a evaluar será juzgado como 'más preciso' conforme su ROC se aleje de ésta función de identidad.
hits_na <- c()     #Creamos un arreglo vacío para los hits en  d' 0
falarms_na <- c()  # Creamos un arreglo vacío para las falsas alarmas en d' 0
for (i in 1:length(bias_c)){                     #Creamos un For donde, para cada posible valor del sesgo C (que relaciona directamente d' con el criterio)
hits[i] <- pnorm((-d/2)-bias_c[i])             #se compute la proporción de la distribución de señal que cae sobre el criterio
falarms[i] <- pnorm((d/2)-bias_c[i])           # y la proporción de la distribución de ruido.
hits_na[i] <- pnorm((d_null/2)-bias_c[i])      #Para referencia, realizamos el mismo cómputo para la d' de 0
falarms_na[i] <- pnorm((-d_null/2)-bias_c[i])
}
plot(fa_rate,h_rate, axes=F, ann=F,  pch=16, col='deepskyblue4', xlim=c(0,1), ylim=c(0,1.1), xlab='F.A. Rate', ylab='Hit Rate')     #Ploteamos las tasas de hits y falsas alarmas obervadas como un punto en el espacio
axis(1,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
axis(2,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
lines(hits,falarms,lwd=2,col='deepskyblue2')        #Dibujamos la curva ROC correspondiente a la d' de nuestro sistema evaluado
lines(hits_na,falarms_na,lwd=1,col='black', lty=2)  #Dibujamos la función de identidad, que corresponde a una d' de 0 (Donde las distribuciones de ruido y señal se empalman por completo)
#lines(c(0.3, 0.38),c(0.25,0.25), lwd=2, lty=1, col="deepskyblue3")
#text(0.3, 0.2, labels="Relaciones posibles entre Hits-F.A., dada la d'", offset=0, cex = 0.7, pos=4)
#text(0.3, 0.1, labels="Relación Hits-F.A. registrada", offset=0, cex = 0.7, pos=4)
#points(.25,0.1, lty=3, pch=16, col='deepskyblue4')
text(fa_rate+0.04, h_rate-0.02, paste("d' =", round(d,4)), offset=0, cex = 0.8, pos=4)
mtext("ROC",3,cex=3, line=-2, f=2)
mtext("Tasa F.A.",1,cex=2, line=2.5, f=2)
mtext("Tasa Hits",2,cex=2, line=2.5, f=2)
mtext("Discriminabilidad alta",3,cex=3, line=-3, f=2, outer=TRUE)
}
# d' nula
rm(list=ls())
for(i in 1:1){
layout(matrix(1:2,ncol=2))
h_rate<- 0.5
fa_rate<- 0.5
k<-qnorm(1-fa_rate,0,1)   #Calculamos la localizacion del Criterio
d<-qnorm(h_rate,0,1)-qnorm(fa_rate,0,1)     #Calculamos d'
c<-k-(d/2)                                  #Calculamos el Sesgo c
beta<-dnorm(k,d,1)/dnorm(k,0,1)             #Calculamos el Sesgo Beta
plot(c(k, k), c(35,35), main="", xlab="", ylab="",type='p', font.lab=2, axes = "FALSE",
xlim= c(-3.5,4.5),  ylim= c(0,.53), pch=16, color='black', cex=2)
lines(seq(k,10,.05),dnorm(seq(k,10,.05),0,1),type='l', lwd=4, col='firebrick3') #FA
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),0,1),type='l', lwd=4, col='dodgerblue3') #Rej
lines(seq(k,10,.05),dnorm(seq(k,10,.05),d,1),type='l', lwd=4, col='forestgreen') #Hit
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),d,1),type='l', lwd=4, col='darkorchid3') #Miss
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),0,1),type='l', lwd=1, lty=3, col='white') #NOISE
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),d,1),type='l', lwd=1, lty=3, col='black') #SIGNAL
axis(1,at=c(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5), labels=c(-4:5), font=2)
lines(c(k,k),c(-0.2,0.48), lwd=2, col='red')
text(-2.3,.45,paste("Falsa Alarma"), cex=1.2, col='firebrick3', f=2)
text(-2.5,.41,paste("Rechazo C."), cex=1.2, col='dodgerblue3', f=2)
text(-3.2,.37,paste("Hit"), cex=1.2, col='forestgreen', f=2)
text(-0.2,.17,paste("K"), cex=1.2, col='red', f=2)
text(-2.7,.33,paste("Omisión"), cex=1.2, col='darkorchid3', f=2)
mtext("Evidencia",1,cex=2, line=2.5, f=2)
mtext("d' = 0",3,cex=3, line=-2, f=2)
hits <- c()   #Creamos un arreglo vacío, que vamos a ir llenando con el Ciclo For, para las tasas de Hits
falarms <- c()  #Creamos un arreglo vacío para las tasas de Falsas Alarmas
bias_c <- seq(-10,10,0.1)
d_null <- 0  #Como referencia, vamos a incluir una curva ROC para una d' de 0. El sistema a evaluar será juzgado como 'más preciso' conforme su ROC se aleje de ésta función de identidad.
hits_na <- c()     #Creamos un arreglo vacío para los hits en  d' 0
falarms_na <- c()  # Creamos un arreglo vacío para las falsas alarmas en d' 0
for (i in 1:length(bias_c)){                     #Creamos un For donde, para cada posible valor del sesgo C (que relaciona directamente d' con el criterio)
hits[i] <- pnorm((-d/2)-bias_c[i])             #se compute la proporción de la distribución de señal que cae sobre el criterio
falarms[i] <- pnorm((d/2)-bias_c[i])           # y la proporción de la distribución de ruido.
hits_na[i] <- pnorm((d_null/2)-bias_c[i])      #Para referencia, realizamos el mismo cómputo para la d' de 0
falarms_na[i] <- pnorm((-d_null/2)-bias_c[i])
}
plot(fa_rate,h_rate, axes=F, ann=F,  pch=16, col='deepskyblue4', xlim=c(0,1), ylim=c(0,1.1), xlab='F.A. Rate', ylab='Hit Rate')     #Ploteamos las tasas de hits y falsas alarmas obervadas como un punto en el espacio
axis(1,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
axis(2,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
lines(hits,falarms,lwd=2,col='deepskyblue2')        #Dibujamos la curva ROC correspondiente a la d' de nuestro sistema evaluado
lines(hits_na,falarms_na,lwd=1,col='black', lty=2)  #Dibujamos la función de identidad, que corresponde a una d' de 0 (Donde las distribuciones de ruido y señal se empalman por completo)
#lines(c(0.3, 0.38),c(0.25,0.25), lwd=2, lty=1, col="deepskyblue3")
#text(0.3, 0.2, labels="Relaciones posibles entre Hits-F.A., dada la d'", offset=0, cex = 0.7, pos=4)
#text(0.3, 0.1, labels="Relación Hits-F.A. registrada", offset=0, cex = 0.7, pos=4)
#points(.25,0.1, lty=3, pch=16, col='deepskyblue4')
text(fa_rate-0.13, h_rate+0.02, paste("d' =", d), offset=0, cex = 0.8, pos=4)
mtext("ROC",3,cex=3, line=-2, f=2)
mtext("Tasa F.A.",1,cex=2, line=2.5, f=2)
mtext("Tasa Hits",2,cex=2, line=2.5, f=2)
mtext("Discriminabilidad nula",3,cex=3, line=-3, f=2, outer=TRUE)
}
# d' pequeña
rm(list=ls())
for(i in 1:1){
layout(matrix(1:2,ncol=2))
h_rate<- 0.84
fa_rate<- 0.49
k<-qnorm(1-fa_rate,0,1)   #Calculamos la localizacion del Criterio
d<-qnorm(h_rate,0,1)-qnorm(fa_rate,0,1)     #Calculamos d'
c<-k-(d/2)                                  #Calculamos el Sesgo c
beta<-dnorm(k,d,1)/dnorm(k,0,1)             #Calculamos el Sesgo Beta
plot(c(k, k), c(35,35), main="", xlab="", ylab="",type='p', font.lab=2, axes = "FALSE",
xlim= c(-3.5,4.5),  ylim= c(0,.53), pch=16, color='black', cex=2)
lines(seq(k,10,.05),dnorm(seq(k,10,.05),0,1),type='l', lwd=4, col='firebrick3') #FA
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),0,1),type='l', lwd=4, col='dodgerblue3') #Rej
lines(seq(k,10,.05),dnorm(seq(k,10,.05),d,1),type='l', lwd=4, col='forestgreen') #Hit
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),d,1),type='l', lwd=4, col='darkorchid3') #Miss
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),0,1),type='l', lwd=1, lty=3, col='white') #NOISE
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),d,1),type='l', lwd=1, lty=3, col='black') #SIGNAL
axis(1,at=c(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5), labels=c(-4:5), font=2)
lines(c(k,k),c(-0.2,0.48), lwd=2, col='red')
text(-2.3,.45,paste("Falsa Alarma"), cex=1.2, col='firebrick3', f=2)
text(-2.5,.41,paste("Rechazo C."), cex=1.2, col='dodgerblue3', f=2)
text(-3.2,.37,paste("Hit"), cex=1.2, col='forestgreen', f=2)
text(0.5,.17,paste("K"), cex=1.2, col='red', f=2)
text(-2.7,.33,paste("Omisión"), cex=1.2, col='darkorchid3', f=2)
mtext("Evidencia",1,cex=2, line=2.5, f=2)
mtext("d' = 1",3,cex=3, line=-2, f=2)
hits <- c()   #Creamos un arreglo vacío, que vamos a ir llenando con el Ciclo For, para las tasas de Hits
falarms <- c()  #Creamos un arreglo vacío para las tasas de Falsas Alarmas
bias_c <- seq(-10,10,0.1)
d_null <- 0  #Como referencia, vamos a incluir una curva ROC para una d' de 0. El sistema a evaluar será juzgado como 'más preciso' conforme su ROC se aleje de ésta función de identidad.
hits_na <- c()     #Creamos un arreglo vacío para los hits en  d' 0
falarms_na <- c()  # Creamos un arreglo vacío para las falsas alarmas en d' 0
for (i in 1:length(bias_c)){                     #Creamos un For donde, para cada posible valor del sesgo C (que relaciona directamente d' con el criterio)
hits[i] <- pnorm((-d/2)-bias_c[i])             #se compute la proporción de la distribución de señal que cae sobre el criterio
falarms[i] <- pnorm((d/2)-bias_c[i])           # y la proporción de la distribución de ruido.
hits_na[i] <- pnorm((d_null/2)-bias_c[i])      #Para referencia, realizamos el mismo cómputo para la d' de 0
falarms_na[i] <- pnorm((-d_null/2)-bias_c[i])
}
plot(fa_rate,h_rate, axes=F, ann=F,  pch=16, col='deepskyblue4', xlim=c(0,1), ylim=c(0,1.1), xlab='F.A. Rate', ylab='Hit Rate')     #Ploteamos las tasas de hits y falsas alarmas obervadas como un punto en el espacio
axis(1,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
axis(2,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
lines(hits,falarms,lwd=2,col='deepskyblue2')        #Dibujamos la curva ROC correspondiente a la d' de nuestro sistema evaluado
lines(hits_na,falarms_na,lwd=1,col='black', lty=2)  #Dibujamos la función de identidad, que corresponde a una d' de 0 (Donde las distribuciones de ruido y señal se empalman por completo)
#lines(c(0.3, 0.38),c(0.25,0.25), lwd=2, lty=1, col="deepskyblue3")
#text(0.3, 0.2, labels="Relaciones posibles entre Hits-F.A., dada la d'", offset=0, cex = 0.7, pos=4)
#text(0.3, 0.1, labels="Relación Hits-F.A. registrada", offset=0, cex = 0.7, pos=4)
#points(.25,0.1, lty=3, pch=16, col='deepskyblue4')
text(fa_rate-0.23, h_rate+0.02, paste("d' =", round(d,4)), offset=0, cex = 0.8, pos=4)
mtext("ROC",3,cex=3, line=-2, f=2)
mtext("Tasa F.A.",1,cex=2, line=2.5, f=2)
mtext("Tasa Hits",2,cex=2, line=2.5, f=2)
mtext("Discriminabilidad baja",3,cex=3, line=-3, f=2, outer=TRUE)
}
# d' grande
rm(list=ls())
for(i in 1:1){
layout(matrix(1:2,ncol=2))
h_rate<- 0.97
fa_rate<- 0.1
k<-qnorm(1-fa_rate,0,1)   #Calculamos la localizacion del Criterio
d<-qnorm(h_rate,0,1)-qnorm(fa_rate,0,1)     #Calculamos d'
c<-k-(d/2)                                  #Calculamos el Sesgo c
beta<-dnorm(k,d,1)/dnorm(k,0,1)             #Calculamos el Sesgo Beta
plot(c(k, k), c(35,35), main="", xlab="", ylab="",type='p', font.lab=2, axes = "FALSE",
xlim= c(-3.5,6.5),  ylim= c(0,.53), pch=16, color='black', cex=2)
lines(seq(k,10,.05),dnorm(seq(k,10,.05),0,1),type='l', lwd=4, col='firebrick3') #FA
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),0,1),type='l', lwd=4, col='dodgerblue3') #Rej
lines(seq(k,10,.05),dnorm(seq(k,10,.05),d,1),type='l', lwd=4, col='forestgreen') #Hit
lines(seq(-4,k,.05),dnorm(seq(-4,k,.05),d,1),type='l', lwd=4, col='darkorchid3') #Miss
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),0,1),type='l', lwd=1, lty=3, col='white') #NOISE
lines(seq(-4,10,.05),dnorm(seq(-4,10,.05),d,1),type='l', lwd=1, lty=3, col='black') #SIGNAL
axis(1,at=c(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5), labels=c(-4:5), font=2)
lines(c(k,k),c(-0.2,0.48), lwd=2, col='red')
text(-3.2,.33,paste("F.A."), cex=1.2, col='firebrick3', f=2)
text(-3.15,.41,paste("R. C."), cex=1.2, col='dodgerblue3', f=2)
text(-3.45,.37,paste("Hit"), cex=1.2, col='forestgreen', f=2)
text(0.5,.15,paste("K"), cex=1.2, col='red', f=2)
text(-2.6,.45,paste("Omisión"), cex=1.2, col='darkorchid3', f=2)
mtext("Evidencia",1,cex=2, line=2.5, f=2)
mtext("d' = 3",3,cex=3, line=-2, f=2)
hits <- c()   #Creamos un arreglo vacío, que vamos a ir llenando con el Ciclo For, para las tasas de Hits
falarms <- c()  #Creamos un arreglo vacío para las tasas de Falsas Alarmas
bias_c <- seq(-10,10,0.1)
d_null <- 0  #Como referencia, vamos a incluir una curva ROC para una d' de 0. El sistema a evaluar será juzgado como 'más preciso' conforme su ROC se aleje de ésta función de identidad.
hits_na <- c()     #Creamos un arreglo vacío para los hits en  d' 0
falarms_na <- c()  # Creamos un arreglo vacío para las falsas alarmas en d' 0
for (i in 1:length(bias_c)){                     #Creamos un For donde, para cada posible valor del sesgo C (que relaciona directamente d' con el criterio)
hits[i] <- pnorm((-d/2)-bias_c[i])             #se compute la proporción de la distribución de señal que cae sobre el criterio
falarms[i] <- pnorm((d/2)-bias_c[i])           # y la proporción de la distribución de ruido.
hits_na[i] <- pnorm((d_null/2)-bias_c[i])      #Para referencia, realizamos el mismo cómputo para la d' de 0
falarms_na[i] <- pnorm((-d_null/2)-bias_c[i])
}
plot(fa_rate,h_rate, axes=F, ann=F,  pch=16, col='deepskyblue4', xlim=c(0,1), ylim=c(0,1.1), xlab='F.A. Rate', ylab='Hit Rate')     #Ploteamos las tasas de hits y falsas alarmas obervadas como un punto en el espacio
axis(1,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
axis(2,at=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), labels=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), font=2)
lines(hits,falarms,lwd=2,col='deepskyblue2')        #Dibujamos la curva ROC correspondiente a la d' de nuestro sistema evaluado
lines(hits_na,falarms_na,lwd=1,col='black', lty=2)  #Dibujamos la función de identidad, que corresponde a una d' de 0 (Donde las distribuciones de ruido y señal se empalman por completo)
#lines(c(0.3, 0.38),c(0.25,0.25), lwd=2, lty=1, col="deepskyblue3")
#text(0.3, 0.2, labels="Relaciones posibles entre Hits-F.A., dada la d'", offset=0, cex = 0.7, pos=4)
#text(0.3, 0.1, labels="Relación Hits-F.A. registrada", offset=0, cex = 0.7, pos=4)
#points(.25,0.1, lty=3, pch=16, col='deepskyblue4')
text(fa_rate+0.04, h_rate-0.02, paste("d' =", round(d,4)), offset=0, cex = 0.8, pos=4)
mtext("ROC",3,cex=3, line=-2, f=2)
mtext("Tasa F.A.",1,cex=2, line=2.5, f=2)
mtext("Tasa Hits",2,cex=2, line=2.5, f=2)
mtext("Discriminabilidad alta",3,cex=3, line=-3, f=2, outer=TRUE)
}
rm(list=ls())
n=1000
noise=0.3
x=array(0,dim=n)
y=array(0,dim=n)
target=c(5,5)
distance=array(NaN,dim=n)
plot(-10:10,-10:10, type="n")
points(target[1],target[2],pch=21,col="red",bg="red",cex=2)
distance[1]=sqrt((x[1]-target[1])^2 + (y[1]-target[2])^2)
for(k in 2:n){
x[k]=x[k-1]+rnorm(1,0,noise)
y[k]=y[k-1]+rnorm(1,0,noise)
distance[k]=sqrt((x[k]-target[1])^2 + (y[k]-target[2])^2)
min_distance=min(distance,na.rm = T)
if(distance[k]<min_distance){
points(x[k],y[k],pch=8)
}
#index=which(distance==min(distance,na.rm = T))
#points(x[index],y[index],pch=21,col="blue",bg="blue",cex=1)
Sys.sleep(.1) ## retard steps 0,1 sec
}
library(shiny); runApp('C:/Users/Alejandro/Desktop/PAPIME2016/AppsFelisa/SDT.R')
